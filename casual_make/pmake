#!/usr/bin/python

'''
Created on 14 maj 2012

@author: hbergk
'''

SCRIPTVERSION="2.0"
SENASTUPPDATERAD="20120715"

#
# Imports
#
import sys
import os
import multiprocessing
from casual.make.make import casual_make
import subprocess
import re

#
# Globals to use
#
GMAKE_OPTIONS=""
FORCE_MAKEMAKE=0
MAKE_PATH="/usr/bin/make"
USER_MAKE_FILE=""

class  Bcolors:
    
    __active = True;
    
    def __grey( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[30;1m'
        else: return '\033[30m'
    
    def __red( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[31;1m'
        else: return '\033[31m'
 
    def __green( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[32;1m'
        else: return '\033[32m'
    
    def __yellow( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[33;1m'
        else: return '\033[33m'
    
    def __blue( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[34;1m'
        else: return '\033[34m'
        
    def __magenta( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[35;1m'
        else: return '\033[35m'
    
    def __cyan( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[36;1m'
        else: return '\033[36m'
    
    def __white( self, bold = False):
        if not self.__active: return ''
        if bold: return '\033[37;1m'
        else: return '\033[37m'
    
    def __error( self, bold = False):
        if not self.__active: return ''
        else: return '\033[0;1;31m'
    
    def __pink(self, bold = False):
        if not self.__active: return ''
        else: return '\033[0;1;35m'
    
    
    def __end(self):
       if not self.__active: return ''
       return '\033[0m'
    
    def magenta( self, string, bold = False):
        return self.__magenta( bold) + string + self.__end()
    
    def error( self, string, bold = False):
        return self.__error( bold) + string + self.__end()
    
    def warning(self, string, bold = False):
        return self.__pink( bold) + string + self.__end()
    
    def blue( self, string, bold = False):
        return self.__blue( bold) + string + self.__end()

    def green( self, string, bold = False):
        return self.__green( bold) + string + self.__end()
    
    def red( self, string, bold = False):
        return self.__red( bold) + string + self.__end()
    
    
    def cyan( self, string, bold = False):
        return self.__cyan( bold) + string + self.__end()
    
    header = cyan
    
    def yellow( self, info, bold = False):
        return self.__yellow(bold) + info + self.__end()
    
    def white( self, string, bold = False):
        return self.__white( bold) + string + self.__end()
    
    info = white
    
    def grey( self, string, bold = False):
        return self.__grey( bold) + string + self.__end()
    
    def none(self, string, bold = False):
        return string
    
    
    def activate( self, value = True):
        self.__active = value

bcolors=Bcolors()





#
# Finding out number of CPUs
#
def numberOfCPUs():
    """ """    
    return multiprocessing.cpu_count()

def handleArguments():
    """Supposed to handle arguments. Not implemented yet."""
    from optparse import OptionParser
    usage = "usage: %prog [options] arg"
    parser = OptionParser(usage)
    
    parser.set_defaults(FORCE_MAKEMAKE=0)
    parser.set_defaults(COLORS=True)
    parser.set_defaults(IGNORE_ERRORS=False)
    parser.set_defaults(USE_VALGRIND=False)
    parser.set_defaults(USER_MAKE_FILE="makefile.mk")
    parser.add_option("-f", "--file", dest="USER_MAKE_FILE") 
    parser.add_option("-d", "--debug", action="store_true", dest="DEBUG")
    parser.add_option("-a", "--analyze", action="store_true", dest="ANALYZE")
    parser.add_option("-r", "--release", action="store_true", dest="RELEASE") 
    parser.add_option("-p", "--force-parallel", action="store_true", dest="FORCE_PARALLEL") 
    parser.add_option("-n", "--force-notparallel", action="store_true", dest="FORCE_NOTPARALLEL")
    parser.add_option("--no-colors", action="store_false", dest="COLORS") 
    parser.add_option("-i","--ignore-errors", action="store_true", dest="IGNORE_ERRORS")
    parser.add_option("--use-valgrind", action="store_true", dest="USE_VALGRIND")  
    
    (options, args) = parser.parse_args()
    
    if args and args[0] in ("make"):
        options.FORCE_MAKEMAKE=1
        
    if args and args[0] in ("clean" , "prep" , "compile" , "export" , "export_headers" ,"cross", "make"):
        options.FORCE_PARALLEL=True
    
    if args and args[0] in ("test") and not options.FORCE_PARALLEL:
        options.FORCE_NOTPARALLEL=1
    
    return (options, args)

def optionsAsString( options):
    """Return option list as string"""
    result=""
    if options.FORCE_PARALLEL:
        result = result + " FORCE_PARALLEL=1 "
    if options.FORCE_NOTPARALLEL:
        result = result + " FORCE_NOTPARALLEL=1 "                  
    if options.DEBUG:
        result = result + " DEBUG=1 "
    if options.ANALYZE:
        result = result + " ANALYZE=1 "                     
    if options.RELEASE:
        result = result + " RELEASE=1 "
    if options.IGNORE_ERRORS:
        result = result + " -i "
    if options.USE_VALGRIND:
        result = result + " VALGRIND=1 "
        
    return result.strip()                



def reformat( line):
    """ reformat output from make and add som colours"""
    
    for regex in reformat.ingore_filters:
        match = regex.match( line)
        if match:
            return ''
     
    for regex, filter in reformat.filters:
        match = regex.match( line)
               
        if match:
            return filter( match)
        
    return line;


reformat.ingore_filters = [
   re.compile(r'(^make.*)Nothing to be done for'),
]

reformat.filters = [ 
    [ re.compile(r'^(CC|g\+\+|clang\+\+).* -o (\S+\.o) (\S+\.cc|\S+\.cpp|\S+\.c).*'),  
     lambda match: bcolors.green( 'compile ') + '(' +  match.group(1) + '): ' + bcolors.white( match.group(3)) + '\n' ],
    [ re.compile(r'(^ar) \S+ (\S+\.a).*'),  
     lambda match: bcolors.blue( 'archive ') + '(' + match.group(1) + '): ' + bcolors.white( match.group(2)) + '\n' ],
    [ re.compile(r'(^(CC)|(g\+\+)) -o (\S+) (?:(\S+\.o) ).*'),
     lambda match: bcolors.blue( 'link ') + '(' + match.group(1) + '): ' + bcolors.white( match.group(4)) + '\n' ],
    [ re.compile(r'^(.*[.]cmk )(.*)'),  
     lambda match: bcolors.cyan( 'makefile: ') + bcolors.blue( match.group(2) ) + ' ' + match.group(1) + '\n'],
    [ re.compile(r'(^make.*:)(.*)'),  
     lambda match: bcolors.header( match.group(1) ) + match.group(2) + '\n'],
    [ re.compile(r'^rm -f (.*)'),  
     lambda match: bcolors.header( 'delete: ' ) + match.group(1) + '\n' ],
    [ re.compile(r'^mkdir( [-].+)*[ ](.*)'),  
     lambda match: bcolors.header( 'create: ' ) + match.group( 2) + '\n' ],
    [ re.compile(r'^casual-build-server[\S\s]+-c (\S+)[\s]+-o (\S+) .*'),  
     lambda match: bcolors.blue( 'buildserver (' + match.group(1) + '): ' ) + bcolors.white( match.group(2)) + '\n' ],
    [ re.compile(r'^[\S\s]*rsync --checksum -i[\s]+(\S+) (.*)'),  
     lambda match: bcolors.blue( 'prepare install: ') + bcolors.white( match.group(1)) +  ' --> ' +  match.group(2) + '\n' ],
    [ re.compile(r'^(>[a-zA-Z+.]+)[\s]+(.*)'),  
     lambda match: bcolors.green( 'updated: ') + match.group(2) + ' ' + bcolors.blue( match.group(1)) + '\n' ],
    [ re.compile(r'^generates makefile.*from[ ](.*)'),  
     lambda match: bcolors.cyan( 'makefile: ') + bcolors.yellow( 'generate ') + bcolors.white( match.group(1)) + '\n' ],
    [ re.compile(r'^casual-build-resource-proxy.*--output[ ]+([^ ]+)'),  
     lambda match: bcolors.blue( 'build-rm-proxy: ') + bcolors.white( match.group(1)) +'\n' ],
];
    
    


if __name__ == '__main__':
    #
    # Kolla om anvandaren har skickat med ngon imake/make-fil
    #
    
    (options, args) = handleArguments()
    
    USER_MAKE_FILE=options.USER_MAKE_FILE
    FORCE_MAKEMAKE=options.FORCE_MAKEMAKE;
            
    CORRESPONDING_CASUAL_MAKE_FILE=os.path.splitext(USER_MAKE_FILE)[0] + ".cmk"; 
    
    
    
    if len(args) != 1:
        GMAKE_OPTIONS=optionsAsString( options) + " all"
    else:
        GMAKE_OPTIONS=optionsAsString( options) + " " + args[0]


    if not options.COLORS:
        bcolors.activate( False)
    
    #
    # Kolla om vi ska generera om
    #
    if FORCE_MAKEMAKE == 1 or not os.path.isfile( USER_MAKE_FILE)  or os.path.getmtime(USER_MAKE_FILE) < os.path.getmtime(CORRESPONDING_CASUAL_MAKE_FILE) :
        if not os.path.isfile( CORRESPONDING_CASUAL_MAKE_FILE ):
            sys.stderr.write( bcolors.error( 'error: Could not find the casaul make file ') + CORRESPONDING_CASUAL_MAKE_FILE)
            sys.exit( 1)

        sys.stdout.write( reformat( 'generates makefile from ' + os.path.abspath( CORRESPONDING_CASUAL_MAKE_FILE))) 
    
        try:
            casual_make( CORRESPONDING_CASUAL_MAKE_FILE)

        except:
            sys.stderr.write( bcolors.error( 'error: ' ) + "Could not generate " + USER_MAKE_FILE + " from " + CORRESPONDING_CASUAL_MAKE_FILE + '\n')
            raise
            sys.exit(1)

    #
    # Find number of CPU:s to set jobs and load
    #
    CPU_COUNT=numberOfCPUs()


    if CPU_COUNT == 0:
        sys.stderr.write( bcolors.warning( "warning: Could not detect how many CPU's the machine has - guess on 2\n"))
        CPU_COUNT=2


    JOB_COUNT=CPU_COUNT * 1.5

    #
    # We let max-jobs be the same... Have no idea if this is a good number.
    #
    MAX_LOAD=JOB_COUNT


    print bcolors.header( "executes: ") + MAKE_PATH + " -j " + str(int(JOB_COUNT)) + " -l " + str(int(MAX_LOAD)) + " --no-builtin-rules --no-keep-going " + GMAKE_OPTIONS + " -f " + USER_MAKE_FILE 


    #
    # Assemble command
    #
    command = MAKE_PATH + " -j " + str(int(JOB_COUNT)) + " -l " + str(int(MAX_LOAD)) + " " + GMAKE_OPTIONS + " --no-builtin-rules --no-keep-going -f " + USER_MAKE_FILE + '\n' 
    
    #
    # Call command
    #
    process = subprocess.Popen( command.split(), bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
    
    while process.poll() is None:
        sys.stdout.write( reformat( process.stdout.readline()))
    
    #
    # Manually "flush" stdout...
    # 
    line = process.stdout.readline()
    
    while( line):
        sys.stdout.write( reformat( line))
        line = process.stdout.readline()

    user_target = ''
    if( args):
        user_target = args[0]

    if process.returncode == 0:
        print 'target ' + bcolors.blue( user_target) + ': ' + bcolors.green( 'SUCCESS', True)
    else:
        print 'target ' + bcolors.blue( user_target) + ': ' + bcolors.error( 'FAILED', True)
    
    #print reformat( process.stdout.readline())
    
    sys.exit( process.returncode)
    