#!/bin/bash

SCRIPTVERSION="1.1"
SENASTUPPDATERAD="20120405"



##################################################################################
#
# Wrapper för make. För att filtrera bort ointressant information
# och fokusera på error och warnings
# 
# Datum	     version	Ändrad av		   Beskrivning
# -------------------------------------------------------------------------------
# 20090430     1.0	   Fredrik Eriksson	Första version
#
##################################################################################


GMAKE_OPTIONS=""
FORCE_MAKEMAKE=0
MAKE_PATH="/usr/bin/make"

#
# Funktion för att kontrollera om det korresponderande argumentet är
# korrekt
#
function arg2kontroll ()
{
   
   if [ "$2" = "" ] || [ "${2:0:1}" = "-" ] 
   then
      printf "\nError:\tWrong usage\n\tno value set to option \"$1\"\n"
      printhelp
      exit 0
   fi
   
   return
}

#
# Finding out number of CPUs
#
function numberOfCPUs()
{
	if [[ $CASUAL_OS == "darwin" ]]; then
		echo $( sysctl -n hw.ncpu )
	else
		echo $( grep "processor" /proc/cpuinfo | wc -l )
	fi
	
	return
}

#
# Choose AWK depending of os
#
function chooseAWK()
{
	if [[ $CASUAL_OS == "darwin" ]]; then
		echo "awk"
	elif [[ $CASUAL_OS == "linux" ]]; then
		echo "gawk"
	else
		echo "awk"
	fi
	
	return
}

#
# Ta reda på vad användaren försker göra
#
while [ $# -gt 0 ]
do
   arg1=$1
   arg2=$2
   
   case "$arg1" in
   "-f" | "-file" | "--file" )
      arg2kontroll $arg1 $arg2
      
      USER_MAKE_FILE=$arg2          
      shift
      shift
   ;;
   "-debug" )
   
      GMAKE_OPTIONS="$GMAKE_OPTIONS DEBUG=1"     
      shift
   ;;
   "-release" )
      GMAKE_OPTIONS="$GMAKE_OPTIONS RELEASE=1" 
      shift
   ;;
   "-force-parallel" )
      GMAKE_OPTIONS="$GMAKE_OPTIONS FORCE_PARALLEL=1" 
      shift
   ;;
	"-force-notparallel" )
      GMAKE_OPTIONS="$GMAKE_OPTIONS FORCE_NOTPARALLEL=1" 
      shift
   ;;
   "make" )
      #
      # Användaren tvingar en omgenerering av makefiler.
		# Körs järnet parallelt
      #
      FORCE_MAKEMAKE=1
      GMAKE_OPTIONS="$GMAKE_OPTIONS FORCE_PARALLEL=1 $arg1"
      shift
   ;;
   "clean" | "prep" | "compile" | "export" | "export_headers" | "cross")
      #
      # clean, prep och compile kan köras i parallel.
      #
      GMAKE_OPTIONS="$GMAKE_OPTIONS FORCE_PARALLEL=1 $arg1"
      shift
   ;;
   *)
      #
      # Vi låter det vi inte känner igen gå vidare till
      # gmake i slutändan...
      #
      GMAKE_OPTIONS="$GMAKE_OPTIONS $arg1"    
      shift 
   ;; 
   esac
done

#
# Kolla om användaren har skickat med någon imake/make-fil
#
if [[ "$USER_MAKE_FILE" == "" ]]
then
   USER_MAKE_FILE="makefile.mk";
fi

USER_MAKE_FILE=`basename $USER_MAKE_FILE`

CORRESPONDING_CASUAL_MAKE_FILE="$( basename $USER_MAKE_FILE .mk).cmk"; 




#
# Kolla om vi ska generera om
#
if [[ "$FORCE_MAKEMAKE" -eq 1 || ! -e $USER_MAKE_FILE  || $USER_MAKE_FILE -ot $CORRESPONDING_CASUAL_MAKE_FILE ]]
then
	
	if [[ ! -e $CORRESPONDING_CASUAL_MAKE_FILE ]]
	then
		echo "error: Could not find the imakefile '$CORRESPONDING_CASUAL_MAKE_FILE'";
		exit 1;
	fi

	echo "info: executes 'casual_make $CORRESPONDING_CASUAL_MAKE_FILE'" 

	casual_make $CORRESPONDING_CASUAL_MAKE_FILE
	
	if [[ $? -ne 0 ]]
	then
		echo "error: Could not generate $USER_MAKE_FILE from $CORRESPONDING_CASUAL_MAKE_FILE" >> /dev/stderr;
		exit 1;
	fi
fi

#
# Detecting system
#
export CASUAL_OS=$( uname -s | tr [:upper:] [:lower:] )

#
# Choosing AWK-dialect
#
AWK=$( chooseAWK )

#
# Ta reda på antalet CPU:er (viruella). Vilket vi utgår ifrån när vi bästämmer jobs och load
#

CPU_COUNT=$( numberOfCPUs )


if (( CPU_COUNT == 0 ))
then
	echo "warning: Could not detect how many CPU's the machine has - guess on 2" >> /dev/stderr;
	CPU_COUNT=2;
fi


#
# Bash förstår inte flyttal, vi multiplcierar med 3 och dividerar med 2
# för att åstakomma * 1.5
#
JOB_COUNT=$(( CPU_COUNT * 3 ))
JOB_COUNT=$(( JOB_COUNT / 2 ))

#
# Vi kör även max load till 1.5x antal CPU:er. Har ingen aning om detta
# är en bra siffra...
#
MAX_LOAD=$JOB_COUNT


echo "info: executes '$MAKE_PATH -j $JOB_COUNT -l $MAX_LOAD --no-builtin-rules --no-keep-going $GMAKE_OPTIONS -f $USER_MAKE_FILE'" 

set -e

$MAKE_PATH -j $JOB_COUNT -l $MAX_LOAD $GMAKE_OPTIONS --no-builtin-rules --no-keep-going -f $USER_MAKE_FILE 2>&1 | $AWK --posix 'BEGIN{
   FS="[ \t]+"
	errors="";
}

function extractSource()
{
	if( match( $0, /[A-Za-z0-9\/_.]+[.]cpp/) > 0)
	{
		return substr( $0, RSTART, RLENGTH);
	}
	else
	{
		return "no sources found in: " + $0;
		
	}
}

function extractOutputTarget()
{
	if( match( $0, /[-]o[ \t]+[A-Za-z0-9\/_.]+/) > 0)
	{
		return substr( $0, RSTART + 3, RLENGTH - 3);
	}
	else
	{
		return "no outupt target found in: " + $0;
		
	}
}

function extractMakefile()
{
   for( i = 1 ; i <= NF ; i++)
   { 
      #printf "%d: [%s]\n", i, $i 
      if( $i == "-f")
      {
         i++;
         return $i;
      }
   }
}

function remove( string, pattern)
{
   sub( pattern, "", string);
   return string;
}


function printObjectfiles()
{
   for( i = 1 ; i <= NF ; i++)
   { 
      #printf "%d: [%s]\n", i, $i 
      if( $i ~ /[a-z][a-zA-z0-9]+\.o[ ]*$/)
      {
         printf "\t%s\n", $i
      }
   }
}


{
   
   if( $0 ~ /(^(CC)|(g\+\+))/ &&  $0 ~ /[.]cpp/  &&  $0 ~ /[-]c/)
   {
      printf "Compile (%s): %s\n", $1, extractSource();
      
      next;
   }
   else if( $0 ~ /purify /)
   {
      printf "Link and Instrument (purify) (this could take som time...): %s\n", extractOutputTarget();
   }
   else if( $0 ~ /buildserver /)
   {
      printf "Buildserver (%s): %s\n", remove( $1, "\47"), extractOutputTarget();
   }
   else if( $0 ~ /buildclient /)
   {
      printf "Buildclient (%s): %s\n", remove( $1, "\47"), extractOutputTarget();
   }
   else if( $0 ~ /^g\+\+.*[ ]-o[ ].+-L[^ ]/)
   {
      # Vi länkar
      printf "Link (%s): %s\n", $1, extractOutputTarget();
      
      next;
   }
   else if( $0 ~ /^cd[ ].*[ ]-f[ ]/)
   {
      printf "Current makefile: %s\n", extractMakefile();
   }
   else if( $0 ~ /^cd[ ]/)
   {
      printf "Current directory: %s\n", $2;
   }
	else if( $0 ~ /([Ee]rror)|(ERROR)|(fatal)|(No rule to make target)|([Ii]nvalid)/ )
   {
		if( $0 !~ /and ["][0-9]+["] warnings[.]/)
		{
			errors = (errors)($0"\n") 
		}
		printf "%s\n", $0
   }
	else
	{
		printf "%s\n", $0
	}  
}
END{
	#
	# Vi skriver bara ut de uppsamlade felen om vi har 
	# hyfsat mycket rader
	#
	if( NR > 50 && length( errors) > 0 )
	{
		printf "\ncollected potential errors (ie. if an output contains some suspicious strings):\n%s\n", errors;
	}
}
'

# 
# Se till så vi returnerar det gmake säger...
#
exit ${PIPESTATUS[0]}

