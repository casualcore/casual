#!/usr/bin/python

'''
Created on 14 maj 2012

@author: hbergk
'''

SCRIPTVERSION="2.0"
SENASTUPPDATERAD="20120715"

#
# Imports
#
import sys
import os
import multiprocessing
from casual.make.make import Casual_Make
import subprocess
import re

#
# Globals to use
#
GMAKE_OPTIONS=""
FORCE_MAKEMAKE=0
MAKE_PATH="/usr/bin/make"
USER_MAKE_FILE=""

class  Bcolors:
    HEADER = '\033[0;35m'
    BLUE = '\033[0;34m'
    GREEN = '\033[0;32m'
    WARNING = '\033[0;23m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    
    
    def header( self, string):
        return self.HEADER + string + self.ENDC
    
    def blue( self, string):
        return self.BLUE + string + self.ENDC

    def green( self, string):
        return self.GREEN + string + self.ENDC
    
    def warning( self, string):
        return self.WARNING + string + self.ENDC
    
    def fail( self, string):
        return self.FAIL + string + self.ENDC
    
    
    def disable(self):
        self.HEADER = ''
        self.BLUE = ''
        self.GREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

bcolors=Bcolors()





#
# Finding out number of CPUs
#
def numberOfCPUs():
    """ """    
    return multiprocessing.cpu_count()

def handleArguments():
    """Supposed to handle arguments. Not implemented yet."""
    from optparse import OptionParser
    usage = "usage: %prog [options] arg"
    parser = OptionParser(usage)
    
    parser.set_defaults(FORCE_MAKEMAKE=0)
    parser.set_defaults(COLORS=True)
    parser.set_defaults(IGNORE_ERRORS=False)
    parser.set_defaults(USE_VALGRIND=False)
    parser.set_defaults(USER_MAKE_FILE="makefile.mk")
    parser.add_option("-f", "--file", dest="USER_MAKE_FILE") 
    parser.add_option("-d", "--debug", action="store_true", dest="DEBUG")
    parser.add_option("-a", "--analyze", action="store_true", dest="ANALYZE")
    parser.add_option("-r", "--release", action="store_true", dest="RELEASE") 
    parser.add_option("-p", "--force-parallel", action="store_true", dest="FORCE_PARALLEL") 
    parser.add_option("-n", "--force-notparallel", action="store_true", dest="FORCE_NOTPARALLEL")
    parser.add_option("--no-colors", action="store_false", dest="COLORS") 
    parser.add_option("-i","--ignore-errors", action="store_true", dest="IGNORE_ERRORS")
    parser.add_option("--use-valgrind", action="store_true", dest="USE_VALGRIND")  
    
    (options, args) = parser.parse_args()
    
    if args and args[0] in ("make"):
        options.FORCE_MAKEMAKE=1
        
    if args and args[0] in ("clean" , "prep" , "compile" , "export" , "export_headers" ,"cross", "make"):
        options.FORCE_PARALLEL=True
    
    return (options, args)

def optionsAsString( options):
    """Return option list as string"""
    result=""
    if options.FORCE_PARALLEL:
        result = result + " FORCE_PARALLEL=1 "
    if options.FORCE_NOTPARALLEL:
        result = result + " FORCE_NOTPARALLEL=1 "                  
    if options.DEBUG:
        result = result + " DEBUG=1 "
    if options.ANALYZE:
        result = result + " ANALYZE=1 "                     
    if options.RELEASE:
        result = result + " RELEASE=1 "
    if options.IGNORE_ERRORS:
        result = result + " -i "
    if options.USE_VALGRIND:
        result = result + " VALGRIND=1 "
        
    return result.strip()                



def reformat( line):
    """ reformat output from make and add som colours"""
    #
    # All regex at once. Takes no time...
    #
    compiling = reformat.compiling.match( line)
    archive = reformat.archive.match( line)
    link = reformat.link.match( line)
    make1 = reformat.make1.match( line)
    make2 = reformat.make2.match( line)
    rm = reformat.make2.match( line)
    buildserver = reformat.buildserver.match( line)
    rsync = reformat.rsync.match( line)
    rsync_output = reformat.rsync_output.match( line)
    
    if compiling:
        return bcolors.green( 'Compile (' + compiling.group(1) + '): ' ) + compiling.group(3) + '\n'
    elif archive:
        return bcolors.blue( 'Archive (' + archive.group(1) + '): ' ) + archive.group(2) + '\n'
    elif link:
        return bcolors.blue( 'Link (' + link.group(1) + '): ' ) + link.group(4) + '\n'
    elif make1:
        return bcolors.header( 'makefile: ') + bcolors.blue(  make1.group(2) ) + ' ' + make1.group(1) + '\n'
    elif make2:
        return bcolors.header( make2.group(1) ) + make2.group(2) + '\n'
    elif rm:
        return bcolors.header( 'rm -f' ) + rm.group(1) + '\n'
    elif buildserver:
        return bcolors.blue( 'Buildserver (' + buildserver.group(1) + '): ' ) + buildserver.group(2) + '\n'
    elif rsync:
        return bcolors.blue( 'prepare install: ') + rsync.group(1) +  ' --> ' + rsync.group(2) + '\n'
    elif rsync_output:
        return bcolors.green( 'updated: ') + rsync_output.group(2) + ' ' + bcolors.blue( rsync_output.group(1)) + '\n'    
    else:
        return line;

reformat.compiling = re.compile(r'^(CC|g\+\+|clang\+\+).* -o (\S+\.o) (\S+\.cc|\S+\.cpp|\S+\.c).*')
reformat.archive = re.compile(r'(^ar) \S+ (\S+\.a).*')
reformat.link = re.compile(r'(^(CC)|(g\+\+)) -o (\S+) (?:(\S+\.o) ).*')
reformat.make1 = re.compile(r'^(.*[.]cmk )(.*)')
reformat.make2 = re.compile(r'(^make.*:)(.*)')
reformat.rm = re.compile(r'^rm -f (.*)')
reformat.buildserver = re.compile(r'^casual-build-server[\S\s]+-c (\S+)[\s]+-o (\S+) .*')
reformat.rsync = re.compile(r'^[\S\s]*rsync --checksum -i[\s]+(\S+) (.*)')
reformat.rsync_output = re.compile(r'^(>[a-zA-Z+.]+)[\s]+(.*)')  

    


if __name__ == '__main__':
    #
    # Kolla om anvandaren har skickat med ngon imake/make-fil
    #
    
    (options, args) = handleArguments()
    
    USER_MAKE_FILE=options.USER_MAKE_FILE
    FORCE_MAKEMAKE=options.FORCE_MAKEMAKE;
            
    CORRESPONDING_CASUAL_MAKE_FILE=os.path.splitext(USER_MAKE_FILE)[0] + ".cmk"; 
    
    
    
    if len(args) != 1:
        GMAKE_OPTIONS=optionsAsString( options) + " all"
    else:
        GMAKE_OPTIONS=optionsAsString( options) + " " + args[0]


    if not options.COLORS:
        bcolors.disable()
    
    #
    # Kolla om vi ska generera om
    #
    if FORCE_MAKEMAKE == 1 or not os.path.isfile( USER_MAKE_FILE)  or os.path.getmtime(USER_MAKE_FILE) < os.path.getmtime(CORRESPONDING_CASUAL_MAKE_FILE) :
        if not os.path.isfile( CORRESPONDING_CASUAL_MAKE_FILE ):
            sys.stderr.write( bcolors.fail( 'error: Could not find the casaul make file ') + CORRESPONDING_CASUAL_MAKE_FILE)
            sys.exit( 1)

        print bcolors.header( 'info: ') + "executes 'casual_make " + CORRESPONDING_CASUAL_MAKE_FILE + "'" 
    
        try:
            Casual_Make( CORRESPONDING_CASUAL_MAKE_FILE).run()

        except:
            sys.stderr.write( bcolors.fail( 'error: ' ) + "Could not generate " + USER_MAKE_FILE + " from " + CORRESPONDING_CASUAL_MAKE_FILE + '\n')
            raise
            sys.exit(1)

    #
    # Find number of CPU:s to set jobs and load
    #
    CPU_COUNT=numberOfCPUs()


    if CPU_COUNT == 0:
        sys.stderr.write( bcolors.warning( "warning: Could not detect how many CPU's the machine has - guess on 2\n"))
        CPU_COUNT=2


    JOB_COUNT=CPU_COUNT * 1.5

    #
    # We let max-jobs be the same... Have no idea if this is a good number.
    #
    MAX_LOAD=JOB_COUNT


    print bcolors.header( "info: executes ") + MAKE_PATH + " -j " + str(int(JOB_COUNT)) + " -l " + str(int(MAX_LOAD)) + " --no-builtin-rules --no-keep-going " + GMAKE_OPTIONS + " -f " + USER_MAKE_FILE 


    #
    # Assemble command
    #
    command = MAKE_PATH + " -j " + str(int(JOB_COUNT)) + " -l " + str(int(MAX_LOAD)) + " " + GMAKE_OPTIONS + " --no-builtin-rules --no-keep-going -f " + USER_MAKE_FILE + '\n' 
    
    #
    # Call command
    #
    process = subprocess.Popen( command.split(), bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
    
    while process.poll() is None:
        sys.stdout.write( reformat( process.stdout.readline()))
    
    #
    # Manually "flush" stdout...
    # 
    line = process.stdout.readline()
    
    while( line):
        sys.stdout.write( reformat( line))
        line = process.stdout.readline()
        
    if process.returncode == 0:
        print 'build: ' + bcolors.green( 'SUCCESS')
    else:
        print 'build: ' + bcolors.fail( 'FAILED')
    
    #print reformat( process.stdout.readline())
    
    sys.exit( process.returncode)
    